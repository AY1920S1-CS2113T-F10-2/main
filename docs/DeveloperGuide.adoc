= Duke 2.0 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/se-edu/addressbook-level3

By: `Team F10-2`      Since: `August 2019`      Licence: `MIT`


== Introduction
=== Purpose

This document illustrates on the architecture designs and the software decisions implemented for the desktop application D2. Duke 2.0 (D2), or Duke Jr.? is a desktop application which enables the prospective applicants of NUS Faculty of Engineering to better plan out their university life. It is an extended task manager, which not only allows for prospective applicants to manage their deadlines and events pertaining to the freshman orientations and document submission, but also provides a coherent and concise platform to compare two engineering degrees of their choice and explore many other details related to the degree. Students can also create lists of engineering degrees of their choice and update it as per their choice. The developer guide will provide you with information such as an overall view of the system hierarchy, logical view of the system’s components, and a process view of the system’s communications that will enable you to help contribute to it too. 

=== Scope

This document describes the software architecture and various other software decisions undertaken for the implementation of D2. The intended audience of this document are developers, designers, software testers of D2 and for those who wish to modify the source files to fit for their own purposes. You may also have a look at it if you wish to understand how this application works. 

<<<
== Setting Up
=== Prerequisites
While Duke 2.0 may work using diffferent versions of Java and with other IDEs, the following are recommended because they have been used for testing:

* Java Development Kit '11'
* Intellij IDE

=== Setup on local Computer


*Manual Import:*

. `Fork` this Repository and `Clone` your remote repository locally to your computer
. Open *Intellij IDE* and set up JDK `11`
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` > `JDK` and select the path of the installed JDK `11`
.. Click `OK`
. Click `Import Project`
. Locate project directory of the cloned repository
. Click `Next`
. Ensure that the `src folder` is checked ✅, and Click `Next` until the `Finish` button appears
. Click the `Finish` button


*Automatic Import using Intellij Check Out:*

. `Fork` this Repository
. Open *Intellij IDE* and set up JDK `11`
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` > `JDK` and select the path of the installed JDK `11`
.. Click `OK`
. Click `Check out from Version Control` > `Git`
. Enter URL of your remote repository > Click `Clone`
. Wait for Intellij to Set Up the project


=== Verifying Setup
. Ensure that Gradle has been imported by running `src/java/javafx/Launcher.java`
. Test out basic Duke 2.0 commands by referring to the User Guide 

<<<
== Design


== Implementation
=== Undo/Redo Feature
==== Implementation

The undo/redo mechanism is done using a simplified memento pattern, since the command classes have already been implemented. This works as an extension of the command classes and makes use of existing code without any 3rd party libraries or additional dependencies.

Each command that modifies the task or degree lists saves the complete previous state within the command as a `memento` object. Thus, when we "unexecute" the command, we call this object and get the complete state of the task or degree list before it was modified by this `command`. 

All of these commands are stored in a `CommandList`, where it has methods to retrieve the previous `command` whenever undo is input, or to manually retrieve a particular command using `undoRedoPointer` whenever redo is input.

Once a command has been undone and the user makes new changes to the task or degree list, all commands after the `undoRedoPointer` will be removed to make way for new commands.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

*Step 1*: The user launches the application, and duke initializes an empty `CommandList`. The `undoRedoPointer` points to -1 as there are currently no elements in `CommandList`.

image::UndoImage1.png[width="900", align="left"]
    

*Step 2*: The user inputs "todo Sleep". This adds a todo task to the `TaskList` and constructs an `AddCommand` object to be executed. Once that `AddCommand` is executed, it saves the current `TaskList` into a memento object, and then it adds "todo Sleep" into the `TaskList`.

*Step 3*: After command execution, the `AddCommand` object is added to `CommandList`. The `undoRedoPointer` increments by 1 and now points to the newly added `AddCommand` at index 0.

image::UndoImage2.png[width="900", align="left"]

TIP: `CommandList` supports modifications to both task and degree lists. Undo simply undoes the modification to one of the lists in order of commands.

*Step 4*: The user inputs "list" to double check the addition of the new task. This executes `PrintCommand` to display the contents of `TaskList`, but does not modify it in any way. Thus, it will not be added to `CommandList`.

*Step 5*: The user inputs "done 3" to mark the 3rd task in `TaskList` as done. This constructs a `ModCommand` object to change the contents of an element in `TaskList`. Once `ModCommand` is executed, it saves the current `TaskList` into a memento object, and then marks the 3rd task as done.

*Step 6*: After command execution, the `ModCommand` object is added to `CommandList`. The `undoRedoPointer` increments by 1 and now points to the newly added `ModCommand` at index 1.

image::UndoImage3.png[width="900", align="left"]


*Step 7*: The user now inputs "undo" to undo the task marking. This will call the `undo` method of `CommandList`, gets the command that `undoRedoPointer` is pointing to (which is `ModCommand` in this case) and unexecute it. `ModCommand` will call its `memento` object and replace the current `TaskList`. The `undoRedoPointer` decrements by 1, and now points to index 0. Note that `ModCommand` is not removed to facilitate redos.

image::UndoImage4.png[width="900", align="left"]


*Step 8*: The user inputs another "undo" to undo the task addition. Similar to step 7, it will call the `undo` method of `CommandList` again and unexecutes the command that `undoRedoPointer` is pointing to. `AddCommand` will call its `memento` object and replace the current `TaskList` with the one that does not have the new task. The `undoRedoPointer` decrements by 1, and now points to index -1.

image::UndoImage5.png[width="900", align="left"]

NOTE: Attempting to undo when there is nothing left to undo will return an error message. Similarly, attempting to redo when there is nothing left to redo will also return an error message.


*Step 9*: The user now inputs "redo" to undo the undo. This will call the `redo` method of `CommandList`. It will first increment the `undoRedoPointer` by 1, and it will then execute the command at the pointed element. This will add "todo Sleep" back to the `TaskList`.

image::UndoImage6.png[width="900", align="left"]


*Step 10*: The user now inputs "done 1" to mark the 1st task as done. Since its now a different command from "done 3" and not "redo", `CommandList` will check if there are commands past `undoRedoPointer`. Currently, `ModCommand` is the element after the one at `undoRedoPointer`, thus `CommandList` will pop all commands from the back of the Stack until `undoRedoPointer`. 

image::UndoImage7.png[width="900", align="left"]


*Step 11*: Once the excess commands are removed, it will proceed back to normal by executing a new `ModCommand` and adding it to `CommandList`, and incrementing `undoRedoPointer` by 1.

image::UndoImage8.png[width="900", align="left"]


==== Design Considerations
How undo/redo executes:

* Alternative 1 (Current Choice): Commands saves a complete previous state if it modifies the degrees or task list
** Pros: 
*** Much easier to implement than a partial state save. 
*** Easier to implement when new commands are added.
*** Common method in the industry to implement undo/redo.
** Cons: 
*** Memory issues once too many commands are executed.
* Alternative 2: Saves the degree and task list to a history.
** Pros: 
*** Straightforward method to save previous states that can be called using undo/redo. 
*** No work needed when new commands are added.
** Cons: 
*** Does not work when a modification changes multiple lists.
*** Memory issues once too many states are saved.
* Alternative 3: Perform the opposite command whenever undo is called. (i.e. undoing add will delete the addition instead of recalling the previous state)
** Pros: 
*** Uses less memory than saving the state every time. 
*** Proper implementation of the memento pattern.
** Cons: 
*** A lot of work needed to "unexecute" every command possible. 
*** More commands means more "unexecution" is needed, and the workload scales higher than alternative 1.

Data Structure to support undo/redo:

* Alternative 1 (Current Choice): `CommandList` class using a stack and a pointer.
** Pros:
*** Much faster pushing and popping the stack than adding into standard `Lists` and `ArrayLists`.
*** More control than a simple stack, as it can also support redos and new commands added after undos.
** Cons:
*** Have to manually write the CommandList mostly from scratch instead of using a pre-esxisting data structure or class. (Although it uses a stack to store and retrieve the commands)

* Alternative 2: `ArrayList` of commands and a pointer.
** Pros:
*** Less work needed to write methods as it uses a pre-existing data structure.
*** Easier for newer developers to understand how the undo/redo function works.
** Cons:
*** Have to do all the work of adding, removing and choosing commands within another class, and can result in messy implementations.
*** Slightly slower than stacks when adding and deleting elements in the `ArrayList`.


=== Degree-Related Tasks
==== Implementation

The actions involving Degree-Related Tasks are performed mostly using the `DegreeTask` class. It extends the `Task` class, eventhough it does not use many methods from the aforementioned class. 

image::DegreeTaskuml.png[width="900", align="left"]


This was done in preparation for some proposed additional changes to this feature that will be discussed later in the document.




Currently, the `DegreeTask` class implements three of the following operations:

* loadDegreeTasks

** This method initializes an Arraylist of TaskLists. When it is called, each of these TaskLists will be populated with the specific tasks that are related to each degree programme. For example, all tasks related to `Computer Engineering` are stored in one of the TaskLists. The other two classes will be able to use this Arraylist to perform operations on the user's TaskList.

* addDegreeTasks

** This method adds all tasks related to a specified degree programme to the user's TaskList.


* removeDegreeTasks

** This method removes all tasks related to a specified degree programme to the user's TaskList.

An example usage scenario details how the mechanism behaves at each step:
+
*Step 1*: The user launches the application, and Duke will initialize an instance of the DegreeTasks command. Duke will call the `loadDegreeTasks` method, and an ArrayList of TaskLists will be instantiated.
+
*Step 2*: The user inputs the command `add ComE` to add Computer Engineering to his choice of degree programmes
+
*Step 3*: The degree programme is added to his list of degree programmes by a seperate, unnamed class. Subsequently, `addDegreeTasks` is called to add all Computer Engineering tasks to 
+


== Testing

== Documentation

<<<
== Appendix A: User Stories

|===
|User Stories | Priority

|As a student entering NUS, I can view all the details of the course and their modules in one place rather than going through multiple websites so that I can avoid confusion 
|High

|As a student applying to NUS, I wish to be able to save a list of possible personal degrees so that I can have a neat way of accessing my list of possible degrees that I have brainstormed to apply for
|High 

|As a student applying to NUS, I wish to compare the details of two majors on a single platform so that I can clearly see what details of the major are important and relevant to me.
|High

|As an impulsive user, I can delete/rank degrees from my personal selection list so that I can correct old decisions that I made the last time in order to have my most updated list at all times.
|High

|As a student presented with too many options, I would want to have a narrowed-down view of the major requirements to make a clearer decision. 
|High

|As a student applying to NUS, I should be able to have a list wherein I can add general/unrestricted modules I am interested in and also have the option to delete them whenever needed so that I can have the most updated list at all times.
|High

|As a prospective student choosing between NUS and other universities’ engineering courses, I will prefer to easily look up all the modules and their details required for the engineering degree, and having one for NUS makes us more attractive than other unis
|High

|As a student applying to NUS, I would want to keep track of all the deadlines to submit documents or housing, and of the various freshman events so that I don't miss out any.
|High

|As a new student, I want to know the module details of the courses as soon as possible, without resorting to manually searching through all modules so that I can know easily learn more about upcoming modules.
|High

|As a student applying to NUS, I want to know all the modules required and their details for the next few years so that I can make a more informed decision.
|High

|As a user who prefers side by side comparisons, I would want to be able to compare between any two majors simultaneously, without the need to switch tabs so as to not get confused. 
|High

|As a novice user, I can type a “help” command and receive all the possible commands that DukeJr provides so that I can use the software to its fullest potential 
|Medium

|As a student applying to NUS and having specific interests, I want to see if the core modules have any overlap with my interests so that I am better able to decide which engineering disciplines suits me the most
|Medium

|As a student applying to NUS and wishing to explore, it should able to propose to me a 2nd Major and point out how many overlaps are there with another degree, so that I am able to decide which second major would be the most beneficial for me.
|Medium

|As a student applying to NUS and who is organised, I would want to view the module requirements for the two degrees in a tabular format which can also provide a percentage similarity between the two.
|Medium

|As a student, I would want to be able to view the complexity of each module in the major and an overall calculation for the complexity of the entire degree so as to see other students’ perceptions regarding the major
|Medium

|As a careless typer, I can type mistakes into the command without DukeJr. crashing so that I do not have to re-run the program at every mistake.
|Medium

|As a user, I can save my personal module selection list onto the hard drive so that I can go back to it when I turn on the program the next time.
|Medium

|As a student applying to NUS, I wish to see a recommended schedule so that I can better plan around
|Medium

|As a student applying to NUS, it can show me past statistics of the module so that I can make a better decision when choosing my modules based on my competency level
|Medium

|As a student applying to NUS, I would like to know the module workload for the upcoming semester so that I can better plan for electives.
|Medium

|As a thorough decision-maker, I want to be able to visit the NUS website associated with the module so that I can view the official webpage of the degree for extremely specific details.
|Medium

|As a person ambitious about a certain engineering discipline, I would want to know about everything NUS offers such as modules, research projects, internships etc. for it so as to make a more informed decision.
|Medium

|As an advanced user, there should be an option to toggle the Module Name display so that I can view it in a format suitable for me.
|Medium

|As a person who likes to keep it short, I would want the user commands to be as simple as possible to search up for anything so that I don’t have to memorize and remember many long commands
|Medium

|As an advanced user, I want to make/delete user defined commands which execute a certain command for me 
|Medium

|As an ambitious student, I can see which majors have a rigorous course curriculum so that I can apply for degree that is personally challenging.
|Medium

|As an enthusiastic student applying to NUS, it can link me to resources (Eg textbooks, external websites) for the module so that I can have a headstart in my studies. 
|Low

|As a practical person, I can view what majors are the most in demand by employers in the job market so that I make my choices on my job prospects.
|Low

|As a student applying to NUS, I would want to be able to view the past cohort sizes so that I know what sort of competition awaits me in my university career.
|Low

|As a lazy typer, duke will auto suggest things according to my most frequently used words so that DukeJr. becomes easier to use as time goes on
|Low

|===



 



<<<
== Appendix B: Use Cases

[cols="4*"] 
|===
|System
|Actor
|Use Case
|Steps

|Duke 2.0 (D2)
|Prospective Applicant to NUS Faculty of Engineering
|View the whole list of possible commands for D2
|User requires help with command syntax +
 +
User types in the command in the following manner: `help` +
 +
D2 returns all the possible commands that it will accept +
 +
User reads the information

|Duke 2.0 (D2)
|Prospective Applicant to NUS Faculty of Engineering
|Check core modules for Bachelor of Engineering (Electrical Engineering)
|User identifies a degree that he/she wishes to research +
 +
User types in the command in the following manner: `details EE` +
 +
D2 displays the degree requirements, including the core modules +
 +
User reads the information

|Duke 2.0 (D2)
|Prospective Applicant to NUS Faculty of Engineering
|Compare core modules for EE and CEG
|User identifies two degrees she wishes to compare +
 +
User types in the command in the following manner: `compare EE CEG` +
 +
D2 displays similar and different modules from the two degrees +
 +
User reads the information

|Duke 2.0 (D2)
|Prospective Applicant to NUS Faculty of Engineering
|Add CEG into degree list and view degree list
|User identifies the degree he/she wishes to add to his/her list of possible degrees +
 +
User types in the command in the following manner: `add EE` +
 +
D2 adds Electrical Engineering to the user’s degree list +
 +
User types in the command in the following manner: `degreelist` +
 +
D2 returns the user’s degree list with Electrical Engineering added

|Duke 2.0 (D2)
|Prospective Applicant to NUS Faculty of Engineering
|Swap CEG with EE in degree list
|User identifies two degrees that he/she wishes to switch in the degree list +
 +
User types in the command in the following manner: `swap CEG EE` +
 +
D2 returns the user’s degree list with CEG and EE having switched indexes 
|===

<<<
== Appendix C: Non-Functional Requirements

. D2 is a fast application.
. D2 can be used on any platform (any PC), and is hence light-weight.
. The information provided is accurate as of the latest semester.
. The application has simple functions, with more options provided for advanced users.
. The application is fairly easy and understandable to navigate through.
. Multi-step commands are available for beginners, as compared to one step for advanced users.
. The application provided tabular formatting of information for better analysis.
. It is inviting to the eye with a well-designed graphical user interface. 

